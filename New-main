#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# main.py

import time
import logging
import sys
import threading
import queue  # å¼•å…¥ä½‡åˆ—æ¨¡çµ„

from transport import create_transport, BaseTransport
from publisher import get_publisher
from decoder import decode_packet, extract_device_address

# è¨­å®š Queue çš„æœ€å¤§å®¹é‡
# å‡è¨­ä¸€ç§’æ”¶åˆ° 10 å€‹åŒ…ï¼Œ100 çš„å®¹é‡å¯ä»¥ç·©è¡ç´„ 10 ç§’çš„ç¶²è·¯æ–·ç·š
QUEUE_MAX_SIZE = 100
PACKET_QUEUE = queue.Queue(maxsize=QUEUE_MAX_SIZE)

def setup_logging(debug_raw: bool) -> None:
    """è¨­å®š logging æ ¼å¼èˆ‡ç­‰ç´š"""
    level = logging.DEBUG if debug_raw else logging.INFO
    logging.basicConfig(
        level=level,
        format="%(asctime)s [%(levelname)s] [%(threadName)s] %(message)s", # åŠ å…¥ threadName æ–¹ä¾¿é™¤éŒ¯
        datefmt="%H:%M:%S",
        stream=sys.stdout,
    )

logger = logging.getLogger("jk_bms_main")

def process_packets_worker(publisher, packet_expire_time):
    """
    [æ¶ˆè²»è€…åŸ·è¡Œç·’]
    è² è²¬ï¼šå¾ä½‡åˆ—å–å‡ºå°åŒ… -> è§£ç¢¼ -> é€é MQTT ç™¼å¸ƒ
    ç‰¹æ€§ï¼šé€™è£¡çš„é˜»å¡ (å¦‚ MQTT é‡é€£) ä¸æœƒå½±éŸ¿ä¸»åŸ·è¡Œç·’çš„æ”¶åŒ…
    """
    worker_logger = logging.getLogger("jk_bms_worker")
    worker_logger.info("ğŸ”§ å°åŒ…è™•ç†å·¥å…µ (Worker) å·²å•Ÿå‹•")
    
    # ç”¨ä¾†æš«å­˜ 0x02 å³æ™‚æ•¸æ“š (ç­‰å¾… 0x01 ID)
    # ç”±æ–¼ Queue æ˜¯ FIFOï¼Œæˆ‘å€‘åªéœ€è¦æš«å­˜æœ€æ–°çš„ä¸€ç­†å³å¯æ‡‰ä»˜ä¸€å•ä¸€ç­”
    pending_realtime_data = None 

    while True:
        try:
            # 1. å¾ä½‡åˆ—å–è³‡æ–™ (é˜»å¡å¼ç­‰å¾…ï¼Œç›´åˆ°æœ‰è³‡æ–™)
            item = PACKET_QUEUE.get()
            
            # ç›£æ§ï¼šå¦‚æœä½‡åˆ—ç©å£“éå¤šï¼Œå°å‡ºè­¦å‘Š (å¯é¸)
            q_size = PACKET_QUEUE.qsize()
            if q_size > QUEUE_MAX_SIZE * 0.8:
                worker_logger.warning(f"âš ï¸ è™•ç†ä½‡åˆ—æ“å¡è­¦å‘Š: ç›®å‰ç©å£“ {q_size} å€‹å°åŒ…")

            if item is None:
                worker_logger.info("ğŸ›‘ æ”¶åˆ°åœæ­¢ä¿¡è™Ÿï¼ŒWorker çµæŸ")
                break
            
            receive_time, pkt_type, packet = item
            
            # --- é–‹å§‹åŸæœ¬çš„æ¥­å‹™é‚è¼¯ ---

            if pkt_type == 0x02:
                # æ”¶åˆ° 0x02ï¼Œæš«å­˜èµ·ä¾†ï¼Œè¨˜éŒ„ç•¶ä¸‹çš„æ¥æ”¶æ™‚é–“
                pending_realtime_data = (receive_time, packet)
                # worker_logger.debug("æ”¶åˆ° 0x02ï¼Œå·²æš«å­˜")

            elif pkt_type == 0x01:
                # æ”¶åˆ° 0x01ï¼Œé€™æ˜¯å¸¶æœ‰ ID çš„è¨­å®šæª”
                
                # A. è§£æè¨­å‚™ ID
                device_id = extract_device_address(packet)
                if device_id == 0:
                    worker_logger.debug("âš ï¸ ç„¡æ³•è§£æ ID æˆ– ID=0ï¼Œç•¥é")
                    PACKET_QUEUE.task_done()
                    continue

                # B. ç™¼å¸ƒ 0x01 è¨­å®šæ•¸æ“š
                try:
                    settings_payload = decode_packet(packet, 0x01)
                    publisher.publish_payload(device_id, 0x01, settings_payload)
                except Exception as e:
                    worker_logger.error(f"âŒ ç™¼å¸ƒ 0x01 å¤±æ•—: {e}")

                # C. æª¢æŸ¥æ˜¯å¦æœ‰å°æ‡‰çš„ 0x02 æš«å­˜
                if pending_realtime_data:
                    r_time, r_packet = pending_realtime_data
                    
                    # è¨ˆç®—é€™å…©åŒ…çš„æ™‚é–“å·®
                    time_diff = receive_time - r_time
                    
                    # æª¢æŸ¥æ˜¯å¦åœ¨æœ‰æ•ˆæ™‚é–“å…§ (ä¾‹å¦‚ 0.4s)
                    if 0 <= time_diff < packet_expire_time:
                        try:
                            # è§£ç¢¼ä¸¦ç™¼å¸ƒ 0x02
                            realtime_payload = decode_packet(r_packet, 0x02)
                            publisher.publish_payload(device_id, 0x02, realtime_payload)
                            
                            worker_logger.info(
                                "ğŸ“¡ BMS %d æ•¸æ“šæ›´æ–° (å»¶é² %.3fs%s)", 
                                device_id, 
                                time_diff,
                                ", Queueç©å£“" if q_size > 5 else ""
                            )
                        except Exception as e:
                            worker_logger.error(f"âŒ ç™¼å¸ƒ 0x02 å¤±æ•—: {e}")
                    else:
                        worker_logger.debug(
                            f"âš ï¸ 0x02 éæœŸ (å·®è· {time_diff:.3f}s > {packet_expire_time}s)ï¼Œä¸Ÿæ£„"
                        )
                    
                    # ç„¡è«–æˆåŠŸå¤±æ•—ï¼Œæ¸…ç©ºæš«å­˜ï¼Œé¿å…èª¤ç”¨åˆ°ä¸‹ä¸€å°è¨­å‚™
                    pending_realtime_data = None
                else:
                    # æ”¶åˆ° 0x01 ä½†æ²’æœ‰ 0x02ï¼Œå¯èƒ½æ˜¯ç¬¬ä¸€åŒ…æˆ–æ¼åŒ…ï¼Œä¸è™•ç†
                    pass

        except Exception as e:
            worker_logger.error(f"âŒ Worker ç™¼ç”Ÿæœªé æœŸéŒ¯èª¤: {e}", exc_info=True)
        finally:
            # æ¨™è¨˜æ­¤ä»»å‹™å®Œæˆ (çµ¦ join ä½¿ç”¨)
            PACKET_QUEUE.task_done()

def main():
    # 1. å»ºç«‹ Transport èˆ‡ Publisher
    transport: BaseTransport = create_transport()
    publisher = get_publisher(config_path="/data/config.yaml")

    # 2. è®€å–è¨­å®š
    app_cfg = getattr(transport, "app_cfg", {}) or {}
    PACKET_EXPIRE_TIME = float(app_cfg.get("packet_expire_time", 0.4))
    debug_raw_log = bool(app_cfg.get("debug_raw_log", False))

    # 3. è¨­å®š Log
    setup_logging(debug_raw_log)

    # 4. å•Ÿå‹•æ¶ˆè²»è€…åŸ·è¡Œç·’ (Consumer Thread)
    # daemon=True ä»£è¡¨ä¸»ç¨‹å¼çµæŸæ™‚ï¼Œé€™å€‹ç·šç¨‹æœƒç›´æ¥è¢«æ®ºæ‰ï¼Œä¸æœƒå¡ä½ç¨‹å¼é€€å‡º
    worker_thread = threading.Thread(
        target=process_packets_worker,
        args=(publisher, PACKET_EXPIRE_TIME),
        name="WorkerThread",
        daemon=True
    )
    worker_thread.start()

    logger.info("ğŸš€ JiKong BMS main (Async Queue Mode) å•Ÿå‹•...")
    logger.info(f"âš™ï¸ å°åŒ…éæœŸæ™‚é–“: {PACKET_EXPIRE_TIME}s, Queueå¤§å°: {QUEUE_MAX_SIZE}")

    # 5. ä¸»è¿´åœˆï¼šç”Ÿç”¢è€… (Producer)
    # é€™è£¡åªåšä¸€ä»¶äº‹ï¼šæ”¶åŒ… -> ä¸Ÿé€² Queue -> ç¹¼çºŒæ”¶åŒ…
    # çµ•å°ä¸å¯ä»¥åœ¨é€™è£¡åš IO Blocking çš„äº‹æƒ… (å¦‚ MQTT publish)
    for pkt_type, packet in transport.packets():
        try:
            # æª¢æŸ¥ Queue æ˜¯å¦æ»¿äº†
            if PACKET_QUEUE.full():
                try:
                    # ä¸Ÿæ£„æœ€èˆŠçš„ä¸€å€‹å°åŒ… (Drop Tail)ï¼Œé¨°å‡ºç©ºé–“çµ¦æœ€æ–°çš„
                    _ = PACKET_QUEUE.get_nowait()
                    PACKET_QUEUE.task_done()
                    logger.warning("âš ï¸ ç³»çµ±éè¼‰ï¼šQueue å·²æ»¿ï¼Œä¸Ÿæ£„èˆŠå°åŒ…ä»¥ç¶­æŒå³æ™‚æ€§")
                except queue.Empty:
                    pass
            
            # æ”¾å…¥ (æ¥æ”¶æ™‚é–“, é¡å‹, å°åŒ…å…§å®¹)
            # ä½¿ç”¨ time.time() ä½œç‚ºæœ€æº–ç¢ºçš„æ¥æ”¶æ™‚é–“æˆ³è¨˜
            PACKET_QUEUE.put((time.time(), pkt_type, packet))
            
        except Exception as e:
            logger.error(f"âŒ ä¸»è¿´åœˆ Enqueue éŒ¯èª¤: {e}")

if __name__ == "__main__":
    main()
